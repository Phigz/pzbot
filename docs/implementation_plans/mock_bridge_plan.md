# Implementation Plan: Mock PZ Bridge (Emulator)

## Goal
Create a python-based emulator (`mock_bridge.py`) that simulates the Project Zomboid Lua environment. This will allow us to test the bot logic, pathfinding, and decision-making without running the actual game client.

## 1. System Components

### 1.1. Mock State Generator
*   **Role**: Replaces the PZ Lua Mod.
*   **Function**: Generates `state.json` updates and writes them to the file system.
*   **Capabilities**:
    *   Simulate a static map (loading chunks from a fake map or procedural gen).
    *   Simulate an "Actor" (the player) moving through this space.
    *   Simulate "Perception": Only include objects/tiles within `scan_radius`.
    *   Simulate Time: Advanced `timestamp` and `tick` monotonically.

### 1.2. Command Processor
*   **Role**: Replaces the `AISurvivorBridge` command handling.
*   **Function**: Watches `input.json` for commands from `pzbot`.
*   **Logic**:
    *   `move_to(x,y)`: Linearly interpolate the Player position towards target over time.
    *   `action_complete`: Simulate action duration (e.g., looting takes 2s) and then update state to idle.

## 2. Proposed Architecture

### file structure
```
pzbot/
  tools/
    mock_bridge/
      __init__.py
      main.py          # Entry point
      world_sim.py     # Simple physics/game state (x,y,z, zombies list)
      file_io.py       # Handles reading input.json / writing state.json
      scenarios/       # Pre-set test cases (e.g. "Kitchen with 1 zombie")
```

### 2.1. World Simulation (`world_sim.py`)
A lightweight state class:
```python
class MockWorld:
    def __init__(self):
        self.player_pos = (100, 100)
        self.zombies = [] # List of (x,y)
        self.map_data = {} # Fake grid of walkable tiles

    def update(self, dt):
        # Move player if walking
        # Move zombies (wander/chase)
        pass
```

### 2.2. The Loop (`main.py`)
```python
while True:
    # 1. Read input.json
    commands = read_commands()
    if commands:
        sim.apply_commands(commands)
    
    # 2. Update Sim
    sim.update(dt=0.1)

    # 3. Render Perception
    state = sim.render_view(radius=15)
    
    # 4. Write state.json
    write_state(state)
    
    time.sleep(0.1)
```

## 3. Usage
We can create a launch script `run_mock.sh` that:
1.  Cleans `state.json` / `input.json`.
2.  Starts `mock_bridge.py` (background).
3.  Starts `pzbot` (foreground).
4.  Kills mock on exit.

## 4. Next Steps
1.  Setup folder structure.
2.  Implement `world_sim.py` with basic movement logic.
3.  Implement `file_io.py` using schemas.
4.  Create a "Empty Room" scenario for testing navigation.

## 5. Schema Compliance & Maintenance
To prevent the mock system from becoming brittle or drifting out of sync with the actual Lua mod:

### 5.1. Dynamic Schema Validation
*   **Action**: The `mock_bridge.py` will load `docs/schemas/output_state.json` at startup.
*   **Validation**: Every `state.json` payload generated by the mock must pass `jsonschema` validation before being written.
*   **Benefit**: If we change the schema but forget to update the mock, the mock will crash immediately with a clear validation error, rather than causing subtle bugs in the bot.

### 5.2. State Factory Pattern
*   **Problem**: Hardcoding JSON blobs in tests makes them hard to update when fields are added/removed.
*   **Solution**: Use a centralized `StateFactory` class in python.
    *   Uses reasonable defaults for all fields (pulled from schema examples where possible).
    *   Tests only specify *deltas* (e.g., `StateFactory.create(player_health=50)`).
    *   When the schema changes, we only need to update the `StateFactory` defaults, and all tests utilizing it will inherit the new structure.
